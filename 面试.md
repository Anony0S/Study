# VUE2 & VUE3

## 生命周期

- vue3 中 setup 函数相当于创建的生命周期，即 vue2 中的 beforeCreate() -> created()
- 使用 keepAlive 组件的时候才会有两个钩子：`onActivated()` `onDeactivated()`



## vue2 中给对象添加新属性不刷新

- 直接修改整个对象的时候会刷新，但是新添加属性不刷新

- Vue.set()：内部会调用 defineReactive(ob.value, key, val) 进行拦截添加响应

  ```js
  Vue.set( target, propertyName/index, value ) // 目标，key或者索引，值
  ```



## 组件通信

- 通过 props 传递

  - vue2 中的 v-model：一个组件上的 `v-model` 默认会利用名为 `value` 的 prop 和名为 `input` 的事件，但是像单选框、复选框等类型的输入控件可能会将 `value` attribute 用于[不同的目的](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/checkbox#Value)。

    可以使用 model 选项进行自定义

    ```js
    Vue.component('base-checkbox', {
      model: {
        prop: 'checked',
        event: 'change'
      },
      props: {
        checked: Boolean
      },
      template: `
        <input
          type="checkbox"
          v-bind:checked="checked"
          v-on:change="$emit('change', $event.target.checked)"
        >
      `
    })
    ```

  - vue3 中 v-model 绑定会产生 **modelValue** 的 props，和 **update:modelValue** 的 emit 事件

- 通过 `$emit/emit` 触发自定义事件

- EventBus：在 vue 原型上挂载一个事件总线，通过 `$on`进行事件监听，通过`$emit`触发事件

- 使用 **ref**：通过 ref 拿到子组件的实例，可以调用子组件中的事件

- 通过 `$parent/$root`搭建中间桥梁，类似于 EventBus

- **provide 和 inject**

  - 在祖先组件定义`provide`属性，返回传递的值

    ```js
    provide(){  
        return {  
            foo:'foo'  
        }  
    }  
    ```

  - 在后代组件通过`inject`接收组件传递过来的值

    ```js
    inject:['foo'] // 获取到祖先组件传递过来的值  
    ```

- **Vuex**

  - state：存放变量
  - mutations：对数据进行同步操作
  - actions：对数据进行异步操作
  - getter：类似于计算属性



## 双向绑定

- MVVM：M代表数据层（model），V代表视图层（view），VM即数据的双向绑定（ViewModel）



## NextTick

在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM

例子：

- 在修改数据后立即获取更新后的DOM，避免DOM更新未完成而获取到旧的状态。

  ```js
  this.message = 'Hello Vue';  
  this.$nextTick(() => {  
    // 获取更新后的DOM  
    console.log(this.$el.textContent); // Hello Vue  
  });
  ```

- 在异步操作后获取更新后的DOM，保证DOM更新完成后再进行操作。

  ```js
  setTimeout(() => {  
    this.message = 'Hello Vue';  
    this.$nextTick(() => {  
      // 获取更新后的DOM  
      console.log(this.$el.textContent); // Hello Vue  
    });  
  }, 1000);
  ```

- 在事件触发后获取更新后的DOM，避免事件处理时DOM还未更新。

  ```js
  this.$refs.myButton.addEventListener('click', () => {  
    this.message = 'Hello Vue';  
    this.$nextTick(() => {  
      // 获取更新后的DOM  
      console.log(this.$el.textContent); // Hello Vue  
    });  
  });
  ```

- **注意：**`$nextTick()` 会返回一个 `Promise` 对象，可以配合await 如：`await this.$nexttick()`



## Mixin

- `Mixin`类通常作为功能模块使用，在需要该功能时“混入”，有利于代码复用又避免了多继承的复杂
- 本质其实就是一个`js`对象，它可以包含我们组件中任意功能选项，如`data`、`components`、`methods`、`created`、`computed`等等
- **局部混入：**在组件中使用 `mixins: [myMixin]` 进行混入，相应的生命周期等会自动执行
- **全局混入：**通过`Vue.mixin()`进行全局的混入，会影响到每一个组件实例（包括第三方组件）
- 当组件存在与`mixin`对象相同的选项的时候，进行递归合并的时候组件的选项会覆盖`mixin`的选项
- 但是如果相同选项为生命周期钩子的时候，会合并成一个数组，先执行`mixin`的钩子，再执行组件的钩子





## Solt

- 默认插槽

  - 子组件

    ```vue
    <template>
        <slot>
          <p>插槽后备的内容</p>
        </slot>
    </template>
    ```

  - 父组件

    ```vue
    <Child>
      <div>默认插槽</div>  
    </Child>
    ```

- 具名插槽

  - 子组件

    ```vue
    <template>
        <slot>插槽后备的内容</slot>
      <slot name="content">插槽后备的内容</slot>
    </template>
    ```

  - 父组件

    ```vue
    <child>
        <template v-slot:default>具名插槽</template>
        <!-- 具名插槽⽤插槽名做参数，不传为默认插槽 -->
        <template v-slot:content>内容...</template>
    </child>
    ```

- 作用域插槽

  - 子组件在作用域上绑定属性来将子组件的信息传给父组件使用，这些属性会被挂在父组件`v-slot`接受的对象上

    父组件中在使用时通过`v-slot:`（简写：`#`）获取子组件的信息，在内容中使用

  - 子组件

    ```vue
    <template> 
      <slot name="footer" testProps="子组件的值">
              <h3>没传footer插槽</h3>
        </slot>
    </template>
    ```

  - 父组件

    ```vue
    <child> 
        <!-- 把v-slot的值指定为作⽤域上下⽂对象 -->
        <template v-slot:default="slotProps">
          来⾃⼦组件数据：{{slotProps.testProps}}
        </template>
        <template #default="slotProps">
          来⾃⼦组件数据：{{slotProps.testProps}}
        </template>
    </child>
    ```

    - **vue3 中**直接使用**作用域插槽**可以用 `v-slot`写在组件身上，但是**具名作用于插槽**需要使用 `#`

      ```vue
      <script setup>
      import slotComp from "@/components/slotComp.vue";
      </script>
      <template>
        <div>插槽</div>
        <hr />
        <slotComp>
          <template #default="val">
            {{ val }}
          </template>
          <template #testSlot="val">
            {{ val }}
          </template>
        </slotComp>
      </template>
      ```

      ```vue
      <template>
        <div>测试内容：插槽之外的内容</div>
        <slot message="message"> </slot>
        <slot
          name="testSlot"
          testVal="footer"
          testProps="子组件的值"
        >
          <!-- <h3>没传footer插槽</h3> -->
        </slot>
      </template>
      ```

  - **VUE2 中插槽总结**

    - `v-slot`属性只能在`<template>`上使用，但在只有默认插槽时可以在组件标签上使用
    - 默认插槽名为`default`，可以省略default直接写`v-slot`
    - 缩写为`#`时不能不写参数，写成`#default`
    - 可以通过解构获取`v-slot={user}`，还可以重命名`v-slot="{user: newName}"`和定义默认值`v-slot="{user = '默认值'}"`



## Vue.observable

- 让一个对象变成响应式数据。`Vue` 内部会用它来处理 `data` 函数返回的对象
- 返回的对象可以直接用于渲染函数和计算属性内，并且会在发生变更时触发相应的更新。也可以作为最小化的跨组件状态存储器



## Keep-alive

`keep-alive`可以设置以下`props`属性：

- `include` - 字符串或正则表达式。只有名称匹配的组件会被缓存
- `exclude` - 字符串或正则表达式。任何名称匹配的组件都不会被缓存
- `max` - 数字。最多可以缓存多少组件实例
- 缓存后如何获取数据：使用 keep-alive 组件会有两个新的生命周期钩子 actived，也可以使用 beforeRouteEnter



## 修饰符

- 表单修饰符：lazy、trim、number
- 事件修饰符：stop、prevent、self、once、capture、passive、native
- 鼠标按钮修饰符：left、right、middle
- 键盘修饰符：(onkeyup onkeydown)

  - 普通键（enter、tab、delete、space、esc、up...）
  - 系统修饰键（ctrl、alt、meta、shift...）
- v-bind修饰符：async、prop、camel

> [参考文档](https://vue3js.cn/interview/vue/modifier.html#%E4%BA%8C%E3%80%81%E4%BF%AE%E9%A5%B0%E7%AC%A6%E7%9A%84%E4%BD%9C%E7%94%A8)



## 自定义指令

- **全局注册：**使用 Vue.directive() 
  - vue3中使用 app.directive()
- **局部注册：**使用 directives 选项
  - Vue3：在 `<script setup>` 中，任何以 `v` 开头的驼峰式命名的变量都可以被用作一个自定义指令。如：`vFocus` 即可以在模板中以 `v-focus` 的形式使用。

- **钩子：**

  - `bind`：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置

  - `inserted`：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)

  - `update`：所在组件的 `VNode` 更新时调用，但是可能发生在其子 `VNode` 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新

  - `componentUpdated`：指令所在组件的 `VNode` 及其子 `VNode` 全部更新后调用

  - `unbind`：只调用一次，指令与元素解绑时调用

  - Vue3 中钩子

    ```js
    const myDirective = {
      // 在绑定元素的 attribute 前
      // 或事件监听器应用前调用
      created(el, binding, vnode, prevVnode) {
        // 下面会介绍各个参数的细节
      },
      // 在元素被插入到 DOM 前调用
      beforeMount(el, binding, vnode, prevVnode) {},
      // 在绑定元素的父组件
      // 及他自己的所有子节点都挂载完成后调用
      mounted(el, binding, vnode, prevVnode) {},
      // 绑定元素的父组件更新前调用
      beforeUpdate(el, binding, vnode, prevVnode) {},
      // 在绑定元素的父组件
      // 及他自己的所有子节点都更新后调用
      updated(el, binding, vnode, prevVnode) {},
      // 绑定元素的父组件卸载前调用
      beforeUnmount(el, binding, vnode, prevVnode) {},
      // 绑定元素的父组件卸载后调用
      unmounted(el, binding, vnode, prevVnode) {}
    }
    ```

- **使用：**表单防止重复提交、图片懒加载、一键Copy、页面水印、权限校验等





## 过滤器 filter

> Vue3 中废弃

- 相当于一个函数，组件中使用选项 `filters`，全局使用 `Vue.filter()`
- 使用时使用 `|`，可以进行串联





## 虚拟 DOM

- `createElement` 创建 `VNode` 的过程，每个 `VNode` 有 `children`，`children` 每个元素也是一个`VNode`，这样就形成了一个虚拟树结构，用于描述真实的`DOM`树结构
- `createComponent`生成`VNode`的三个关键流程
  - 构造子类构造函数`Ctor`
  - `installComponentHooks`安装组件钩子函数
  - 实例化 `vnode`



## Diff 算法

- `diff` 算法是一种通过同层的树节点进行比较的高效算法
- 比较只会在同层级进行, 不会跨层级比较
- 在diff比较的过程中，循环从两边向中间比较

> [参考内容](https://vue3js.cn/interview/vue/diff.html#%E4%B8%80%E3%80%81%E6%98%AF%E4%BB%80%E4%B9%88)



## Axios 封装

- 封装内容：设置超时请求时间、设置请求头、根据项目环境判断使用哪个请求地址、错误处理、响应请求拦截等



## SSR



## 权限管理

- 接口权限

  - 一般采用 JWT 验证方式
  - 另外一种 Seeion + Cookie 每次请求 Cookie 会自动带上

- 路由权限

  - 初始化即挂载全部路由，并且在路由上标记相应的权限信息，每次路由跳转前做校验
  - 初始化时先挂载不需要权限的路由，获取用户信息后，通过 `addRoutes` 动态添加路由

- 菜单权限

  - 菜单与路由分离，菜单由后端返回（常规）
  - 菜单和路由都由后端返回

- 按钮权限

  - v-if：页面过多时控制不方便

  - **自定义指令：**

    - ```js
      import Vue from 'vue'
      /**权限指令**/
      const has = Vue.directive('has', {
          bind: function (el, binding, vnode) {
              // 获取页面按钮权限
              let btnPermissionsArr = [];
              if(binding.value){
                  // 如果指令传值，获取指令参数，根据指令参数和当前登录人按钮权限做比较。
                  btnPermissionsArr = Array.of(binding.value);
              }else{
                  // 否则获取路由中的参数，根据路由的btnPermissionsArr和当前登录人按钮权限做比较。
                  btnPermissionsArr = vnode.context.$route.meta.btnPermissions;
              }
              if (!Vue.prototype.$_has(btnPermissionsArr)) {
                  el.parentNode.removeChild(el);
              }
          }
      });
      // 权限检查方法
      Vue.prototype.$_has = function (value) {
          let isExist = false;
          // 获取用户按钮权限
          let btnPermissionsStr = sessionStorage.getItem("btnPermissions");
          if (btnPermissionsStr == undefined || btnPermissionsStr == null) {
              return false;
          }
          if (value.indexOf(btnPermissionsStr) > -1) {
              isExist = true;
          }
          return isExist;
      };
      export {has}
      ```

      ```vue
      <el-button @click='editClick' type="primary" v-has>编辑</el-button>
      ```

      



## 如何解决跨域

- 后端将`Access-Control-Allow-Origin` 值设为我们目标`host`
- Proxy代理：
  - Vue配置文件设置代理
  - 服务端设置代理
  - Nginx设置代理（同上）



## History 模式 404 问题

- 原因：单页面应用只有 Index，页面跳转为 JS 通过拦截浏览器路由进行跳转，而 Nginx 只配置了根目录下的 index.html，当请求其他资源时就会提示 404 

- 解决：配置Nginx

  ```nginx
  server {
    listen  80;
    server_name  www.xxx.com;
  
    location / {
      index  /data/dist/index.html;
      try_files $uri $uri/ /index.html; # 对于所有路径都会返回 index.html 文件
    }
  }
  ```

  ```js
  // router.js 注意 Vue中路由匹配由上到下，所有路由应该放在最下面
  export default new Router({
    mode: 'history',
    routes: [
      // ...
      {
        name: '404',
        path: '/404',
        component: () => import('@/views/notFound.vue')
      },
      {
        path: '*',    // 此处需特别注意至于最底部
        redirect: '/404'
      }
    ],
  })
  ```





## Vue3 和 Vue2 区别

- 能够使用 webpack 的 tree-shaking，减小打包体积
- Template 支持多个节点
- setup语法糖
- 响应式 API：ref、reactive、readonly、computed、watch、watchEffect
- 生命周期钩子
- ref 使用
- 模板指令：
  - v-model 更改
  - v-if 和 v-for 优先级
- `<template>` 没有特殊指令的标记 (`v-if/else-if/else`、`v-for` 或 `v-slot`) 现在被视为普通元素，并将生成原生的 `<template>` 元素，而不是渲染其内部内容。
- TypeScript 支持
- 组合式 API -> 编写 hooks 提高逻辑复用性

> [参考链接](https://vue3js.cn/interview/vue/vue3_vue2.html#%E4%BA%8C%E3%80%81vue3%E6%96%B0%E5%A2%9E%E7%89%B9%E6%80%A7)



## Composition API

- 在逻辑组织和逻辑复用方面，`Composition API`是优于`Options API`
- 因为`Composition API`几乎是函数，会有更好的类型推断。
- `Composition API`对 `tree-shaking` 友好，代码也更容易压缩
- `Composition API`中见不到`this`的使用，减少了`this`指向不明的情况
- 如果是小型组件，可以继续使用`Options API`，也是十分友好的



## Tree-Shaking

得益于Composition API的优势，以及 ES Module打包时可以将没有用到的代码删除减小打包时的体积，提高代码运行速度





# ES6

## let、const

- 变量提升 
- 作用域



## 数组新增

- 拓展运算符

- `Array.from()`：将类似数组的对象和可遍历`（iterable）`的对象（包括 `ES6` 新增的数据结构 `Set` 和 `Map`）转化为真正的数组

  - ```js
    let arrayLike = {
        '0': 'a',
        '1': 'b',
        '2': 'c',
        length: 3
    };
    let arr2 = Array.from(arrayLike); // ['a', 'b', 'c']
    ```

  - ```js
    // 接受第二个参数，用来对每个元素进行处理，将处理后的值放入返回的数组
    Array.from([1, 2, 3], (x) => x * x)
    // [1, 4, 9]
    ```

- `Array.of()`：用于将一组值，转换为数组

  - ```js
    Array() // [] 没有参数返回空数组
    Array(3) // [, , ,] 只有一个参数为数组长度
    Array(3, 11, 8) // [3, 11, 8] 不少于2个以上参数转化为包含参数的数组
    ```

- `find()`、`findIndex()`

- `keys()`、`values()`、`entries()`：这些方法为遍历数组使用，分别为 键、值、键值对

- `includes()`



## 对象新增

- 对象中的变量和方法可以进行简写，**但是方法简写不能用作构造函数**

  - ```js
    const obj = {
      f() {
        this.foo = 'bar';
      }
    };
    
    new obj.f() // 报错
    ```

  - 使用 [] 包括表达式定义属性名，但不支持对象作为属性名，可以使用 Map 定义，支持所有数据的属性名

  - **super** 关键字：总是指向当前对象的原型对象

    - ```js
      const proto = {
        foo: 'hello'
      };
      
      const obj = {
        foo: 'world',
        find() {
          return super.foo;
        }
      };
      
      Object.setPrototypeOf(obj, proto); // 为obj设置原型对象
      obj.find() // "hello"
      ```

  - 拓展运算符：属于浅拷贝，相当于 `Object.assign()` 方法

  - 遍历：`for...in` `Object.keys()`

- 新增方法：

  - Object.is()：严格判断是否相等

  - Object.assign()：浅拷贝对象合并，第一个参数是目标对象，后面的参数都是源对象

  - Object.getOwnPropertyDescriptors()

  - Object.setPrototypeOf()，Object.getPrototypeOf()

  - Object.keys()，Object.values()，Object.entries()

    - ```js
      const obj = { foo: 'bar', baz: 42 };
      Object.entries(obj)
      // [ ["foo", "bar"], ["baz", 42] ]
      ```

  - Object.fromEntries()： 用于将一个键值对数组转为对象，类似上面反转



## 函数新增

- 参数可以设置默认值
- 箭头函数
  - return 的简写方式：一句表达式或者圆括号包裹
  - 函数体内的`this`对象，就是定义时所在的对象，而不是使用时所在的对象
  - 不可以当作构造函数，也就是说，不可以使用`new`命令，否则会抛出一个错误





## Set Map

- Set：类似于数组，但是值都是唯一的，是一个构造函数（使用时需要 new）
  - 包含增删改查 及 遍历 的一些方法
- Map： 类似于对象，键值对的有序列表，而键和值都可以是任意类型
  - map.size：返回 Map 成员总数
  - 其他方法和属性同Set数据





# JavaScript

## 数据类型



## 数组方法



## 字符串方法



## 类型转换机制

- 显示转换
- 隐式转换



## == 和 === 区别

- == 会进行隐式转换



## 深浅拷贝

- 浅拷贝
  - `Object.assign`
  - `Array.prototype.slice()`, `Array.prototype.concat()`
  - 使用拓展运算符实现的复制
- 深拷贝
  - lodash
  - Json.parse(Json.stringfy(Obj))：但是这种方式存在弊端，会忽略`undefined`、`symbol`和`函数`
  - 循环递归



## 闭包

- 内层函数访问到外层函数的作用域
- 在函数中创建另一个函数，就形成了闭包



## 作用域链

- 作用域：变量或函数生效的区域或集合
  - 全局作用域
  - 函数作用域
  - 块级作用域：在大括号中使用 let const 声明的变量存在于块级作用域中
- 作用域链：内层作用域会向上一层作用域查找，这种从内部向外部的变量查找过程就形成了**作用域链**



##  原型、原型链



## 继承

> 使子类具有父类的各种属性和方法

- 原型链继承（鸡肋）
- 构造函数继承（借助 call）
- 组合继承
- 原型式继承
- 寄生式继承
- 寄生组合式继承



## This

- `this`永远指向的是最后调用它的对象

- 通过构建函数`new`关键字生成一个实例对象，此时`this`指向这个实例对象
- `new`过程遇到`return`一个对象，此时`this`指向为返回的对象
- 如果返回一个简单类型的时候，则`this`指向实例对象
- 如果返回一个简单类型的时候，则`this`指向实例对象
- 如果返回的是`null`虽然也是对象，但是此时`new`仍然指向实例对象





## typeof、instanceof

- typeof：可以判断基础数据类型、但是 null 为 Object。除了函数，其他的复杂数据类型都为 Object
- `instanceof` 运算符用于检测构造函数的 `prototype` 属性是否出现在某个实例对象的原型链上
- `Object.prototype.toString.call()`：可以判断所有数据类型





## 事件代理

- 在冒泡阶段完成
- 事件委托，会把一个或者一组元素的事件委托到它的父层或者更外层元素上，真正绑定事件的是外层元素，而不是目标元素
- 应用：比如 ul > li 结构，可以直接给 ul 绑定事件，在新增或者删减 li 的时候就不用重新绑定事件了

- `focus`、`blur`这些事件没有事件冒泡机制，所以无法进行委托绑定事件
- `mousemove`、`mouseout`这样的事件，虽然有事件冒泡，但是只能不断通过位置去计算定位，对性能消耗高，因此也是不适合于事件委托的



## New 过程

- 创建一个新的对象`obj`
- 将对象与构建函数通过原型链连接起来
- 将构建函数中的`this`绑定到新建的对象`obj`上
- 根据构建函数返回类型作判断，如果是原始值则被忽略，如果是返回对象，需要正常处理





