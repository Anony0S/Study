## 生命周期

- vue3 中 setup 函数相当于创建的生命周期，即 vue2 中的 beforeCreate() -> created()
- 使用 keepAlive 组件的时候才会有两个钩子：`onActivated()` `onDeactivated()`



## vue2 中给对象添加新属性不刷新

- 直接修改整个对象的时候会刷新，但是新添加属性不刷新

- Vue.set()：内部会调用 defineReactive(ob.value, key, val) 进行拦截添加响应

  ```js
  Vue.set( target, propertyName/index, value ) // 目标，key或者索引，值
  ```



## 组件通信

- 通过 props 传递

  - vue2 中的 v-model：一个组件上的 `v-model` 默认会利用名为 `value` 的 prop 和名为 `input` 的事件，但是像单选框、复选框等类型的输入控件可能会将 `value` attribute 用于[不同的目的](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/checkbox#Value)。

    可以使用 model 选项进行自定义

    ```js
    Vue.component('base-checkbox', {
      model: {
        prop: 'checked',
        event: 'change'
      },
      props: {
        checked: Boolean
      },
      template: `
        <input
          type="checkbox"
          v-bind:checked="checked"
          v-on:change="$emit('change', $event.target.checked)"
        >
      `
    })
    ```

  - vue3 中 v-model 绑定会产生 **modelValue** 的 props，和 **update:modelValue** 的 emit 事件

- 通过 `$emit/emit` 触发自定义事件

- EventBus：在 vue 原型上挂载一个事件总线，通过 `$on`进行事件监听，通过`$emit`触发事件

- 使用 **ref**：通过 ref 拿到子组件的实例，可以调用子组件中的事件

- 通过 `$parent/$root`搭建中间桥梁，类似于 EventBus

- **provide 和 inject**

  - 在祖先组件定义`provide`属性，返回传递的值

    ```js
    provide(){  
        return {  
            foo:'foo'  
        }  
    }  
    ```

  - 在后代组件通过`inject`接收组件传递过来的值

    ```js
    inject:['foo'] // 获取到祖先组件传递过来的值  
    ```

- **Vuex**

  - state：存放变量
  - mutations：对数据进行同步操作
  - actions：对数据进行异步操作
  - getter：类似于计算属性



## 双向绑定

- MVVM：M代表数据层（model），V代表视图层（view），VM即数据的双向绑定（ViewModel）



## NextTick

在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM

例子：

- 在修改数据后立即获取更新后的DOM，避免DOM更新未完成而获取到旧的状态。

  ```js
  this.message = 'Hello Vue';  
  this.$nextTick(() => {  
    // 获取更新后的DOM  
    console.log(this.$el.textContent); // Hello Vue  
  });
  ```

- 在异步操作后获取更新后的DOM，保证DOM更新完成后再进行操作。

  ```js
  setTimeout(() => {  
    this.message = 'Hello Vue';  
    this.$nextTick(() => {  
      // 获取更新后的DOM  
      console.log(this.$el.textContent); // Hello Vue  
    });  
  }, 1000);
  ```

- 在事件触发后获取更新后的DOM，避免事件处理时DOM还未更新。

  ```js
  this.$refs.myButton.addEventListener('click', () => {  
    this.message = 'Hello Vue';  
    this.$nextTick(() => {  
      // 获取更新后的DOM  
      console.log(this.$el.textContent); // Hello Vue  
    });  
  });
  ```

- **注意：**`$nextTick()` 会返回一个 `Promise` 对象，可以配合await 如：`await this.$nexttick()`



## Mixin

- `Mixin`类通常作为功能模块使用，在需要该功能时“混入”，有利于代码复用又避免了多继承的复杂
- 本质其实就是一个`js`对象，它可以包含我们组件中任意功能选项，如`data`、`components`、`methods`、`created`、`computed`等等
- **局部混入：**在组件中使用 `mixins: [myMixin]` 进行混入，相应的生命周期等会自动执行
- **全局混入：**通过`Vue.mixin()`进行全局的混入，会影响到每一个组件实例（包括第三方组件）
- 当组件存在与`mixin`对象相同的选项的时候，进行递归合并的时候组件的选项会覆盖`mixin`的选项
- 但是如果相同选项为生命周期钩子的时候，会合并成一个数组，先执行`mixin`的钩子，再执行组件的钩子





## Solt

- 默认插槽

  - 子组件

    ```vue
    <template>
        <slot>
          <p>插槽后备的内容</p>
        </slot>
    </template>
    ```

  - 父组件

    ```vue
    <Child>
      <div>默认插槽</div>  
    </Child>
    ```

- 具名插槽

  - 子组件

    ```vue
    <template>
        <slot>插槽后备的内容</slot>
      <slot name="content">插槽后备的内容</slot>
    </template>
    ```

  - 父组件

    ```vue
    <child>
        <template v-slot:default>具名插槽</template>
        <!-- 具名插槽⽤插槽名做参数，不传为默认插槽 -->
        <template v-slot:content>内容...</template>
    </child>
    ```

- 作用域插槽

  - 子组件在作用域上绑定属性来将子组件的信息传给父组件使用，这些属性会被挂在父组件`v-slot`接受的对象上

    父组件中在使用时通过`v-slot:`（简写：`#`）获取子组件的信息，在内容中使用

  - 子组件

    ```vue
    <template> 
      <slot name="footer" testProps="子组件的值">
              <h3>没传footer插槽</h3>
        </slot>
    </template>
    ```

  - 父组件

    ```vue
    <child> 
        <!-- 把v-slot的值指定为作⽤域上下⽂对象 -->
        <template v-slot:default="slotProps">
          来⾃⼦组件数据：{{slotProps.testProps}}
        </template>
        <template #default="slotProps">
          来⾃⼦组件数据：{{slotProps.testProps}}
        </template>
    </child>
    ```

    - **vue3 中**直接使用**作用域插槽**可以用 `v-slot`写在组件身上，但是**具名作用于插槽**需要使用 `#`

      ```vue
      <script setup>
      import slotComp from "@/components/slotComp.vue";
      </script>
      <template>
        <div>插槽</div>
        <hr />
        <slotComp>
          <template #default="val">
            {{ val }}
          </template>
          <template #testSlot="val">
            {{ val }}
          </template>
        </slotComp>
      </template>
      ```

      ```vue
      <template>
        <div>测试内容：插槽之外的内容</div>
        <slot message="message"> </slot>
        <slot
          name="testSlot"
          testVal="footer"
          testProps="子组件的值"
        >
          <!-- <h3>没传footer插槽</h3> -->
        </slot>
      </template>
      ```

  - **VUE2 中插槽总结**

    - `v-slot`属性只能在`<template>`上使用，但在只有默认插槽时可以在组件标签上使用
    - 默认插槽名为`default`，可以省略default直接写`v-slot`
    - 缩写为`#`时不能不写参数，写成`#default`
    - 可以通过解构获取`v-slot={user}`，还可以重命名`v-slot="{user: newName}"`和定义默认值`v-slot="{user = '默认值'}"`



## Vue.observable

- 让一个对象变成响应式数据。`Vue` 内部会用它来处理 `data` 函数返回的对象
- 返回的对象可以直接用于渲染函数和计算属性内，并且会在发生变更时触发相应的更新。也可以作为最小化的跨组件状态存储器



## Keep-alive

`keep-alive`可以设置以下`props`属性：

- `include` - 字符串或正则表达式。只有名称匹配的组件会被缓存
- `exclude` - 字符串或正则表达式。任何名称匹配的组件都不会被缓存
- `max` - 数字。最多可以缓存多少组件实例
- 缓存后如何获取数据：使用 keep-alive 组件会有两个新的生命周期钩子 actived，也可以使用 beforeRouteEnter



## 修饰符

- 表单修饰符：lazy、trim、number
- 事件修饰符：stop、prevent、self、once、capture、passive、native
- 鼠标按钮修饰符：left、right、middle
- 键盘修饰符：(onkeyup onkeydown)

  - 普通键（enter、tab、delete、space、esc、up...）
  - 系统修饰键（ctrl、alt、meta、shift...）
- v-bind修饰符：async、prop、camel

> [参考文档](https://vue3js.cn/interview/vue/modifier.html#%E4%BA%8C%E3%80%81%E4%BF%AE%E9%A5%B0%E7%AC%A6%E7%9A%84%E4%BD%9C%E7%94%A8)



## 自定义指令

- **全局注册：**使用 Vue.directive() 
  - vue3中使用 app.directive()
- **局部注册：**使用 directives 选项
  - Vue3：在 `<script setup>` 中，任何以 `v` 开头的驼峰式命名的变量都可以被用作一个自定义指令。如：`vFocus` 即可以在模板中以 `v-focus` 的形式使用。

- **钩子：**

  - `bind`：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置

  - `inserted`：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)

  - `update`：所在组件的 `VNode` 更新时调用，但是可能发生在其子 `VNode` 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新

  - `componentUpdated`：指令所在组件的 `VNode` 及其子 `VNode` 全部更新后调用

  - `unbind`：只调用一次，指令与元素解绑时调用

  - Vue3 中钩子

    ```js
    const myDirective = {
      // 在绑定元素的 attribute 前
      // 或事件监听器应用前调用
      created(el, binding, vnode, prevVnode) {
        // 下面会介绍各个参数的细节
      },
      // 在元素被插入到 DOM 前调用
      beforeMount(el, binding, vnode, prevVnode) {},
      // 在绑定元素的父组件
      // 及他自己的所有子节点都挂载完成后调用
      mounted(el, binding, vnode, prevVnode) {},
      // 绑定元素的父组件更新前调用
      beforeUpdate(el, binding, vnode, prevVnode) {},
      // 在绑定元素的父组件
      // 及他自己的所有子节点都更新后调用
      updated(el, binding, vnode, prevVnode) {},
      // 绑定元素的父组件卸载前调用
      beforeUnmount(el, binding, vnode, prevVnode) {},
      // 绑定元素的父组件卸载后调用
      unmounted(el, binding, vnode, prevVnode) {}
    }
    ```

- **使用：**表单防止重复提交、图片懒加载、一键Copy、页面水印、权限校验等





## 过滤器 filter

> Vue3 中废弃

- 相当于一个函数，组件中使用选项 `filters`，全局使用 `Vue.filter()`
- 使用时使用 `|`，可以进行串联





## 虚拟 DOM

- `createElement` 创建 `VNode` 的过程，每个 `VNode` 有 `children`，`children` 每个元素也是一个`VNode`，这样就形成了一个虚拟树结构，用于描述真实的`DOM`树结构
- `createComponent`生成`VNode`的三个关键流程
  - 构造子类构造函数`Ctor`
  - `installComponentHooks`安装组件钩子函数
  - 实例化 `vnode`



## Diff 算法

- `diff` 算法是一种通过同层的树节点进行比较的高效算法
- 比较只会在同层级进行, 不会跨层级比较
- 在diff比较的过程中，循环从两边向中间比较

> [参考内容](https://vue3js.cn/interview/vue/diff.html#%E4%B8%80%E3%80%81%E6%98%AF%E4%BB%80%E4%B9%88)



## Axios 封装

- 封装内容：设置超时请求时间、设置请求头、根据项目环境判断使用哪个请求地址、错误处理、响应请求拦截等



## SSR



## 权限管理

- 接口权限
  - 一般采用 JWT 验证方式
  - 另外一种 Seeion + Cookie 每次请求 Cookie 会自动带上
- 路由权限
  - 初始化即挂载全部路由，并且在路由上标记相应的权限信息，每次路由跳转前做校验
  - 初始化时先挂载不需要权限的路由，获取用户信息后，通过 `addRoutes` 动态添加路由
- 菜单权限
- 按钮权限
